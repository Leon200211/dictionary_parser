# Dictionary Parser - Парсер словарных статей

Парсер для обработки словарных статей из Word документов с поддержкой специальных тегов разметки.

## Принцип работы

**Вход**: 1 файл .docx (или несколько файлов)
**Выход**: 1 файл .json + опциональный _errors.json для каждого входного файла

Парсер автоматически обрабатывает **все файлы .docx** из папки `input/` независимо от их названия.

## Возможности

- Парсинг Word документов (.docx) с извлечением словарных статей
- Поддержка 13 типов специальных тегов разметки (# ##, {1}, {2}, +6+, и т.д.)
- Универсальная обработка секций: как простых, так и с одним уровнем вложенности
- Извлечение вариантов написания слов с опциональными окончаниями
- Детальное логирование ошибок в JSON и текстовом формате
- Экспорт результатов в структурированный JSON формат
- Продолжение работы при обнаружении ошибок

## Быстрый старт

### Предварительные требования

- Docker
- Docker Compose

### Установка и запуск

1. Клонируйте репозиторий:
```bash
git clone <repository-url>
cd dictionary_parser
```

2. Создайте необходимые директории:
```bash
mkdir -p input output logs
```

3. Поместите ваши Word документы (.docx) в папку `input/`

   **⚠️ Важно:** Парсер обрабатывает **ВСЕ файлы .docx** в папке `input/` независимо от их названия

4. Запустите парсер через Docker Compose:
```bash
docker-compose up --build
```

Или для разового запуска:
```bash
docker-compose run --rm parser
```

## Структура проекта

```
dictionary_parser/
├── input/              # Входные Word документы (.docx)
├── output/             # Выходные JSON файлы
│   ├── filename.json           # Основные результаты
│   └── filename_errors.json    # Ошибки (опционально)
├── logs/               # Текстовые логи
│   ├── errors.log      # Ошибки парсинга
│   └── links.log       # Ссылочные статьи
├── parser.py           # Основной скрипт парсера
├── test_parser.py      # Локальный тестовый скрипт
├── requirements.txt    # Python зависимости
├── Dockerfile          # Docker образ
├── docker-compose.yml  # Docker Compose конфигурация
└── README.md          # Документация
```

## Формат входных данных

### Поддерживаемые теги

- `#` ... `##` - начало и конец словарной статьи
- `{1}` ... `{1}` - заголовок статьи
- `{2}` ... `{2}` - грамматические пометы
- `{3}` ... `{3}` - толкования
- `{4}` ... `{4}` - произношение
- `{5}` ... `{5}` - грамматические формы
- `+6+` ... `+6+` - иллюстрации
- `{7}` ... `{7}` - словообразование
- `{8}` ... `{8}` - словарные фиксации
- `+9+` ... `+9+` - синонимы
- `+10+` ... `+10+` - антонимы
- `{11}` ... `{11}` - фразеология
- `{12}` ... `{12}` - морфемика
- `{13}` ... `{13}` - этимология

### Пример статьи

```
#{1}ааро́новский{1}##
#{1}аа́ленский{1} (от Аа́лен, геол.)##
#{1}автолизи́ровать(ся){1} {1}и аутолизи́ровать(ся){1}##
```

## Формат выходных данных

Для каждого входного файла `.docx` создаются выходные файлы:

- `filename.json` - основные результаты парсинга
- `filename_errors.json` - опциональный файл с ошибками (создается только при наличии ошибок)

### Основной файл (filename.json)

```json
[
  {
    "writings": [
      {
        "word": "аароновский",
        "value": "ааро́новский"
      }
    ],
    "sections": [
      {
        "type": 1,
        "content": "<strong>ааро́новский</strong>"
      }
    ]
  }
]
```

**Примечание**: секции с вложенными подсекциями содержат только поле `sections` (без `content`), секции без вложенных содержат только поле `content` (без `sections`).

### Файл с ошибками (filename_errors.json)

Создается только при обнаружении ошибок:

```json
[
  {
    "block": "#текст статьи с ошибкой##",
    "errors": [
      {
        "type": "PARSE_ERROR",
        "message": "Описание ошибки"
      }
    ]
  }
]
```

## Логирование

Парсер также создает текстовые лог-файлы в директории `logs/`:

- `errors.log` - ошибки парсинга (текстовый формат)
- `links.log` - ссылочные статьи (типа "См. Другое_слово")

## Локальная разработка

Для разработки без Docker:

```bash
# Создайте виртуальное окружение
python -m venv venv
source venv/bin/activate  # Linux/Mac
# или
venv\Scripts\activate  # Windows

# Установите зависимости
pip install -r requirements.txt

# Запустите парсер (через тестовый скрипт)
python3 test_parser.py
# или напрямую
python3 parser.py
```

`test_parser.py` использует локальные пути (`./input`, `./output`, `./logs`), тогда как `parser.py` по умолчанию использует Docker пути (`/app/input`, `/app/output`, `/app/logs`).

## Настройка

Вы можете изменить пути к директориям в `parser.py`:

```python
parser = DictionaryParser(
    input_dir='/app/input',
    output_dir='/app/output',
    logs_dir='/app/logs'
)
```

Или через переменные окружения в `docker-compose.yml`:

```yaml
environment:
  - INPUT_DIR=/app/input
  - OUTPUT_DIR=/app/output
  - LOGS_DIR=/app/logs
```

## Особенности обработки

### Секция 1 (Заголовки)

- Слова сохраняются без лишних символов (только буквы и тире)
- Буква `ё` заменяется на `е`
- Все буквы приводятся к нижнему регистру
- Поддержка опциональных окончаний: `слово(ся)` → `слово`, `словося`
- Игнорирование числовых индексов (¹, ², ³)

### Ссылочные статьи

Статьи вида "СЛОВО. См. Другое_слово" не обрабатываются и сохраняются в `logs/links.log`

### Обработка ошибок

При обнаружении ошибок (вложенные статьи, незакрытые теги), парсер:
1. Логирует ошибку в `logs/errors.log`
2. Продолжает обработку следующих статей

## Примеры использования

### Обработка файлов

**Важно**: Парсер автоматически обрабатывает **все файлы .docx** из папки `input/`

```bash
# Поместите один или несколько файлов в input/
cp my_dictionary.docx input/
# или
cp *.docx input/

# Запустите парсер
docker-compose run --rm parser

# Результаты будут в output/:
# - my_dictionary.json (основные результаты)
# - my_dictionary_errors.json (если были ошибки)
```

### Обработка через локальный Python

```bash
# Поместите файлы в input/
cp *.docx input/

# Запустите парсер локально
python3 test_parser.py

# Результаты в output/
```

## Поддержка

Для вопросов и предложений создавайте issue в репозитории проекта.

## Лицензия

MIT
